I got a little bogged down in the coding for this hub.  I encountered some bugs and it took me longer than the time I had available this week to fix them all completely.  At first, I thought to delay publication of this hub, then I thought that talking about programming without talking about bugs is a bit like talking about sex without mentioning pregnancy, diseases or the complexities of human relationships; it doesn't give a whole picture of the experience.

As mentioned in the previous hub in this series, I need to parse equations the user enters in order to insert path integral/derrivative functions at appropriate points in the equation, also for security to prevent reflected javascript injection attacks.

An equation may consist of some combination of <term> ::= <term> <op> <term> (e.g. "Math.sin(x) + Math.cos(x)"), <term> ::= "x", or <term> ::= <function>( <term> ).  For now, <op> may be one of "+-/*".

There are various methods that could be used to parse this simple grammar, but I choose to use regular expressions, because I thought they would do a large part of the work for me, and they are a powerful programming feature, that I wanted to talk about.

My goal with a regular expression is to find a function name or literal followed by an operator or a parenthesis, then to repeat the process with the left-over portion of the string, if there is anything left-over.  It seems like the following regular expression would be perfect for this:
"^\s*([a-zA-Z._0-9]+)\s*([+\-/*()])(.*)".  [ ^ is the beginning of the string, \s is any whitespace, * is zero or more occurances of the preceding character, [] indicates a set of characters, a-z indicates all the characters between a and z, () makes the portion of the data matching that part of the regular expression available for later reference, . represents any character ]  The problem I encountered is that, at least in the version of javascript that I am using, the RegExp constructor crashes when evaluating this regular expression. After some experimenting, it seems including the literal ()'s in the expression is leading to the problem, and various attempts at escaping them, don't help.  So, this problem is not going to yield to direct frontal assult, and I don't want to wait for javascript to get fixed.

I later came up with the regular expression "\s*([a-zA-Z._0-9]+)\s*(\S?)(.*)", which still doesn't do exactly what I want, but it comes close enough that I can continue with my coding.  The operators aren't getting captured by the \S? term.  It seems the regex engine prefers to find "none of those" and include the operator as the first character of "(.*)".  Whatever, I can make it work this way.

Aside from regular expressions, and bugs, the other key concept of this hub is recursion.  Since expressions can be nested to an arbitrary level,  I need some mechanism to remember that I have seen a left paren and carry on with evaluating whatever equation may be between the opening left paren and its matching right paren.  Recursion (having my parsing function call itself) seems to be a natural way of recording the encounter with the left paren.  That information will be saved on the call stack, and the call stack can get as deep as will be needed.

I wrote a couple of functions that create closures for the path integral and path derrivative of a given expression: diff() and integrate(). They are a little complicated. Each of these creates two closures used to form the x and y components of a path function, a closure for that path function itself, another closure for the derrivative/integal function of that path, and finally a closure to generate a single valued derivative or integration function.  The complexity seems to be necessary to mesh with the code I had previously written, plus produce a single valued function that can be used within an equation that the user would enter. It could probably be simplified with an overall refactoring of my code, but the computer won't mind making a few more closures.  It has been many years since I have had to worry about computer resources on a small issue like this.  So, I won't bother. 

If the parsing code encounters "D( <term> )", it will replace this with "generatedfn[i]", within the expression it will present to eval, which will be the path derivative function for <term>.  If the parsing code encounters S( <term> ), it will similarly insert the appropriate path integral function into the equation.

If you recall, cos is the derivative of sin.  In the illustration you can see that D( Math.sin(x) ) produces a curve sloping down on either side of the y axis.  So, I believe the basic design of the parsing and generation of the derrivative function is working, but there are some remaining bugs.

As to remaining bugs:
	The parsing is finicky about spaces.  This is probably a sign that I need to struggle further with my regular expressions.
	The coordinates are often not on the x and y axis relative to the equation being graphed. This is a timing issue, because the axis are now drawn before the graph area is scaled.
	The parsing is still not completely secure.  I should probably define what functions and terms I want to allow, and enforce that those are the only ones accepted.

	In my next hub in this series I will present a completed javascript based graphing calculator with these bugs fixed.  If you have gone though this series up to here, and been able to follow the techniques that I am using, you are pretty far along in learning to program, or already knew.  I haven't presented this material as a tutorial.  So, if you didn't know it already, you will need to research some of the techniques and terms that I am using on your own, which I think is fine.  There are lots of existing tutorials on the Web on all of these topics.  You could view this hub series as a table of contents for things you would be well served to learn on your own.  Or, you may already know them better than I do.